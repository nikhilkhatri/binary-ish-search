#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#define SIZE 1000000

typedef struct Node{
	struct Node *left;
	struct Node *right;
	int data;
} node;

node *prepare_bbst(int *arr, int len);
int serialize(node *tree, int *data, int *sz, int i);
int sbst_search(int *pre, int *sz, int len, int data);
long time_elapsed(struct timespec start, struct timespec end);

int main(){
	// seed
	srand((int)time(NULL));
	
	int *arr;
	arr = malloc(SIZE * sizeof(int));

	// Generate [SIZE] random numbers
	int i;
	for(i=0;i<SIZE;i++){
		arr[i] = rand();
	}

	// Populate Balanced BST
	node *root = NULL;
	root = prepare_bbst(arr, SIZE);
	
	int *pre;
	int *sz;
	pre = malloc(SIZE * sizeof(int));
	sz = malloc(SIZE * sizeof(int));

	// Serialize the tree into pre and sz arrays
	serialize(root, pre, sz, 0);

	// begin search - use total time
	struct timespec start_time;
	struct timespec end_time;

	// This variable exists to ensure that the compiler does not optimise out the loop
	// There are probably neater ways to do this
	int throw = 0;

	clock_gettime(CLOCK_REALTIME, &start_time);
	for(int j=0;j<50;j++){
		for(i=0;i<SIZE;i++){
			throw += sbst_search(pre, sz, SIZE, arr[i]);
		}
	}
	clock_gettime(CLOCK_REALTIME, &end_time);

	// print time elapsed in microseconds
	printf("time: %ld us\n", time_elapsed(start_time, end_time));
	
	// ensure compiler doesnt eliminate throw, and hence the loop
	printf("%d\n", throw);
}

int serialize(node *tree, int *data, int *sz, int i){
	/*
		Recursive function to serialise a binary tree into two arrays

		@param tree:	pointer to root of a binary tree
		@param data:	array which will hold the preorder traversal of the tree
		@paaram sz:		array which will hold sizes of each subtree
		@param i:		index at which to begin filling data and sz first call should pass this as zero
						(ideally one extra function should be added which calls the recursive one)
		@return: returns size of the subtree rooted at tree
	*/
	
	if(tree == NULL){
		return 0;
	}
	
	// Fill in preorder list
	data[i] = tree->data;
	
	// initialise size of this subtree
	int this_size = 1;
	
	// recursive calls
	this_size += serialize(tree->left, data, sz, i+this_size);
	this_size += serialize(tree->right, data, sz, i+this_size);
	
	// this_size = 1 + lchild's size + rchild's size

	sz[i] = this_size;
	
	return this_size;
}

int sbst_search(int *pre, int *sz, int len, int data){
	/*
		Performs search in a serialised BST which was generated by prepare_bbst
		(This condition is necessary since this function assumes no node can have only a right child without a left)
		
		@param pre:	preorder listing of a BST
		@param sz:	sub tree size array of BST
		@param len: length of pre and sz arrays
		@param data: query term

		@return:	index of data in pre

	*/

	int root = 0;
	while(root < len){
		if(pre[root] == data){ // found element, return index
			return root;
		}
		if(data < pre[root]){ // go to left child
			root++;
		}
		else { // implicit: data > pre[root] : go to right child
			// was there a left child? - removed this condition
			// changes in bbst creation ensure that condition doesnt arise
			root += sz[root+1] + 1;
		}
	}

	// data not found
	return -1;
}

long time_elapsed(struct timespec start, struct timespec end){
	// gets time elapsed in microseconds
	return ((end.tv_sec - start.tv_sec) * 1000000) + (end.tv_nsec - start.tv_nsec)/1000;
}

int comp(const void *a, const void *b){ 
	// Lightweight comparator required by qsort
	return (*((int *) a)) - (*((int *) b));
}

node *_prepare_bbst_rec(int *arr, int l, int r){
	/*
		recursive helper to make a balanced BST

		Makes middle element the root of this subtree
		Then recurse on left and right subtrees

		@param arr	sorted array of integers
		@param l	leftmost index of this subtree
		@param r	rightmost index of this subtree

	*/

	if(l>r){
		return NULL;
	}
	
	// Make node for this subtree's root
	node *root = malloc(sizeof(node));
	int mid = (l+r+1) / 2; // Ensure ceil of middle is taken, this ensures no single right child ever
	
	// make middle element root
	root->data = arr[mid];

	// call self recursively for left and right subtrees
	root->left = _prepare_bbst_rec(arr, l, mid-1);
	root->right = _prepare_bbst_rec(arr, mid+1, r);

	return root;
}

node *prepare_bbst(int *arr, int len){
	/*
		Prepares a balanced BST from an array
		
		@param arr	array of len integers
		@param len	# of integers
	
		Important note: The way the recursive helper is written,
		it is guaranteed that no node will have a right child unless it also has a left child
		This reduces one extra check in the sbst_search function
	*/

	// Make a copy of arr so we dont modify it
	int *brr = malloc(len * sizeof(int));
	memcpy(brr, arr, len * sizeof(int));
	
	// sort the copy
	qsort(brr, len, sizeof(int), comp);

	// call recursive helper
	node *root = _prepare_bbst_rec(brr, 0, len-1);

	// delete the copy we made
	free(brr);

	return root;
}

